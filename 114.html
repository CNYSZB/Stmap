<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>写实行星 - 菜单定制与彩色高度图版</title>
    <style>
        :root { --accent: #00e5ff; --glass: rgba(15, 15, 15, 0.9); }
        body { margin: 0; background: #000; color: #fff; font-family: -apple-system, sans-serif; overflow: hidden; height: 100dvh; }
        
        /* 侧边菜单逻辑 */
        #menu-container {
            position: absolute; top: 15%; left: 20px;
            z-index: 1000; display: flex; flex-direction: column; gap: 10px;
        }
        #menu-toggle {
            background: var(--accent); color: #000; border: none; padding: 12px 20px;
            border-radius: 12px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,229,255,0.3);
            width: fit-content;
        }
        #ui-panel {
            width: 300px; background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15); border-radius: 20px;
            padding: 20px; display: none; /* 默认隐藏 */
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }
        
        .control-row { display: grid; grid-template-columns: 1fr; gap: 15px; margin-top: 10px; }
        label { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; display: block; }
        input[type="number"] { width: 100%; background: #000; border: 1px solid #333; color: var(--accent); padding: 8px; border-radius: 8px; box-sizing: border-box; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #333; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: var(--accent); border-radius: 50%; border: 2px solid #000; }

        /* 导出按钮组 */
        .export-group { position: absolute; right: 20px; top: 20%; display: flex; flex-direction: column; gap: 12px; }
        .fab { width: 60px; height: 60px; border-radius: 50%; border: none; font-size: 10px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        #btn-geo { background: var(--accent); color: #000; }
        #btn-hgt { background: #ffaa00; color: #000; } /* 高度图按钮 */
        #btn-cld { background: #fff; color: #000; }
        #btn-nor { background: #8080ff; color: #fff; }
        
        #toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: #fff; color: #000; padding: 10px 20px; border-radius: 30px; font-size: 12px; display: none; z-index: 2000; }
    </style>
</head>
<body>

<div id="toast">贴图已导出</div>

<div id="menu-container">
    <button id="menu-toggle">☰ 星球设置</button>
    <div id="ui-panel">
        <label>星球种子</label>
        <input type="number" id="seedIn" value="40662">
        <div class="control-row">
            <div class="item"><label>海平面 (海拔零点)</label><input type="range" id="seaIn" min="20" max="80" value="48"></div>
            <div class="item"><label>云层密度</label><input type="range" id="cloudIn" min="0" max="100" value="50"></div>
            <div class="item"><label>赤道沙漠化</label><input type="range" id="eqDesertIn" min="0" max="100" value="30"></div>
            <div class="item"><label>北极推进</label><input type="range" id="iceNIn" min="0" max="160" value="30"></div>
            <div class="item"><label>南极推进</label><input type="range" id="iceSIn" min="0" max="160" value="30"></div>
        </div>
    </div>
</div>

<div class="export-group">
    <button id="btn-geo" class="fab">导出<br>地形</button>
    <button id="btn-hgt" class="fab">彩色<br>高度图</button>
    <button id="btn-cld" class="fab">导出<br>云层</button>
    <button id="btn-nor" class="fab">导出<br>法线</button>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

    // 核心噪声算法
    const noiseShader = `
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            vec4 j = p - 49.0 * floor(p * (1.0/49.0));
            vec4 x_ = floor(j * (1.0/7.0)); vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * (2.0/7.0) - 1.0; vec4 y = y_ * (2.0/7.0) - 1.0;
            vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m; return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        float fbm(vec3 p, int oct) {
            float v = 0.0; float amp = 0.5;
            for (int i=0; i<8; i++) { if(i >= oct) break; v += amp * snoise(p); p *= 2.15; amp *= 0.5; }
            return v;
        }
    `;

    // 核心星球颜色与高度逻辑
    const planetLogic = `
        float getH(vec3 p, float uSeed) {
            vec3 sOff = vec3(uSeed * 0.13, uSeed * 0.47, uSeed * 0.71);
            return fbm(p * 1.5 + sOff, 8) * 0.5 + 0.5;
        }
        
        // 彩色高度图着色逻辑
        vec3 getHeightMapColor(float h, float uSeaLevel) {
            if(h < uSeaLevel) {
                return mix(vec3(0.0, 0.0, 0.3), vec3(0.0, 0.5, 1.0), h/uSeaLevel); // 深蓝到浅蓝
            } else {
                float landH = (h - uSeaLevel) / (1.0 - uSeaLevel);
                if(landH < 0.1) return mix(vec3(0.1, 0.6, 0.2), vec3(0.5, 0.8, 0.3), landH/0.1); // 绿地
                if(landH < 0.4) return mix(vec3(0.5, 0.8, 0.3), vec3(0.9, 0.8, 0.5), (landH-0.1)/0.3); // 黄土
                if(landH < 0.8) return mix(vec3(0.9, 0.8, 0.5), vec3(0.4, 0.2, 0.1), (landH-0.4)/0.4); // 褐山
                return mix(vec3(0.4, 0.2, 0.1), vec3(1.0, 1.0, 1.0), (landH-0.8)/0.2); // 雪山
            }
        }

        vec3 getPlanetColor(vec3 p, float uSeed, float uSeaLevel, float uIceN, float uIceS, float uEqDesert) {
            vec3 sOff = vec3(uSeed * 0.13, uSeed * 0.47, uSeed * 0.71);
            float h = getH(p, uSeed);
            bool isWater = h < uSeaLevel;
            float lat = p.y;
            
            vec3 col;
            if(isWater) {
                col = mix(vec3(0.05, 0.1, 0.22), vec3(0.01, 0.03, 0.08), smoothstep(0.0, 0.7, (uSeaLevel-h)/uSeaLevel));
            } else {
                float m = fbm(p * 2.5 + sOff + 100.0, 5) * 0.5 + 0.5;
                float desertStrength = uEqDesert / 100.0;
                float areaLimit = pow(max(0.0, 1.0 - abs(lat) * 1.5), 1.8); 
                float eqFactor = desertStrength * areaLimit;
                float finalBiomeFactor = mix(m, m * 0.15, eqFactor);
                vec3 bio = mix(vec3(0.75,0.65,0.45), vec3(0.35,0.5,0.25), smoothstep(0.35,0.45,finalBiomeFactor));
                bio = mix(bio, vec3(0.08,0.28,0.12), smoothstep(0.65,0.75,finalBiomeFactor));
                col = mix(bio, vec3(0.35), smoothstep(0.45, 0.85, (h-uSeaLevel)));
            }
            float noise = snoise(p * 10.0 + sOff) * 0.15; 
            float detail = snoise(p * 50.0) * 0.03; 
            float ice = max(smoothstep(1.1-(uIceN/100.0)+noise, 1.25-(uIceN/100.0)+noise, lat+detail),
                            smoothstep(-1.1+(uIceS/100.0)-noise, -1.25+(uIceS/100.0)-noise, lat-detail));
            return mix(col, mix(vec3(0.98,0.98,1.0), vec3(0.75,0.88,0.98), isWater?1.0:0.0), ice);
        }
    `;

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(38, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 15;
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const pMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uSeaLevel:{value:0.48}, uIceN:{value:30}, uIceS:{value:30}, uEqDesert:{value:30} },
        vertexShader: `varying vec3 vPos, vN; void main() { vPos = position; vN = normalize(normalMatrix*normal); gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `${noiseShader} ${planetLogic}
            varying vec3 vPos, vN; uniform float uSeed, uSeaLevel, uIceN, uIceS, uEqDesert;
            void main() {
                vec3 p = normalize(vPos);
                vec3 c = getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS, uEqDesert);
                float d = max(dot(vN, normalize(vec3(1,0.8,1))), 0.0) * 0.8 + 0.2;
                gl_FragColor = vec4(c * d, 1.0);
            }`
    });

    const cMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uCloud:{value:0.5} },
        vertexShader: `varying vec3 vPos; void main() { vPos = position; gl_Position = projectionMatrix*modelViewMatrix*vec4(position*1.03, 1.0); }`,
        fragmentShader: `${noiseShader}
            varying vec3 vPos; uniform float uSeed, uCloud;
            void main() {
                float n = fbm(normalize(vPos)*1.3 + uSeed + 500.0, 5)*0.5+0.5;
                gl_FragColor = vec4(vec3(1.0), smoothstep(1.0-uCloud, 1.2-uCloud, n)*0.8);
            }`,
        transparent: true, depthWrite: false
    });

    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), pMat));
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), cMat));

    // UI 菜单展开逻辑
    const menuToggle = document.getElementById('menu-toggle');
    const uiPanel = document.getElementById('ui-panel');
    menuToggle.onclick = () => {
        const isVisible = uiPanel.style.display === 'block';
        uiPanel.style.display = isVisible ? 'none' : 'block';
    };

    const ui = { seed:document.getElementById('seedIn'), sea:document.getElementById('seaIn'), cloud:document.getElementById('cloudIn'), eqD:document.getElementById('eqDesertIn'), iceN:document.getElementById('iceNIn'), iceS:document.getElementById('iceSIn') };
    const sync = () => {
        pMat.uniforms.uSeed.value = cMat.uniforms.uSeed.value = parseFloat(ui.seed.value);
        pMat.uniforms.uSeaLevel.value = ui.sea.value/100;
        cMat.uniforms.uCloud.value = ui.cloud.value/100;
        pMat.uniforms.uEqDesert.value = parseFloat(ui.eqD.value);
        pMat.uniforms.uIceN.value = ui.iceN.value; pMat.uniforms.uIceS.value = ui.iceS.value;
    };
    Object.values(ui).forEach(el => el.oninput = sync);

    // 导出逻辑（含彩色高度图模式 mode 3）
    function doExport(mode) {
        const W = 4096, H = 2048;
        const rt = new THREE.WebGLRenderTarget(W, H);
        const exMat = new THREE.ShaderMaterial({
            uniforms: { ...pMat.uniforms, uCloud:{value:cMat.uniforms.uCloud.value}, uMode:{value:mode} },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: `${noiseShader} ${planetLogic}
                varying vec2 vUv; uniform float uSeed, uSeaLevel, uIceN, uIceS, uEqDesert, uCloud, uMode;
                void main() {
                    float lon = (vUv.x*2.0-1.0)*3.14159265; float lat = (vUv.y*2.0-1.0)*1.57079632;
                    vec3 p = vec3(cos(lat)*sin(lon), sin(lat), cos(lat)*cos(lon));
                    if(uMode == 0.0) gl_FragColor = vec4(getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS, uEqDesert), 1.0);
                    else if(uMode == 1.0) gl_FragColor = vec4(vec3(1.0), smoothstep(1.0-uCloud, 1.2-uCloud, fbm(p*1.3+uSeed+500.0, 6)*0.5+0.5));
                    else if(uMode == 2.0) {
                        float h = getH(p, uSeed); float eps = 0.001;
                        float hR = getH(vec3(cos(lat)*sin(lon+eps), sin(lat), cos(lat)*cos(lon+eps)), uSeed);
                        float hU = getH(vec3(cos(lat+eps)*sin(lon), sin(lat+eps), cos(lat+eps)*cos(lon)), uSeed);
                        gl_FragColor = vec4(normalize(vec3((h-hR)*25.0, (h-hU)*25.0, 1.0))*0.5+0.5, 1.0);
                    } else { // 彩色高度图
                        gl_FragColor = vec4(getHeightMapColor(getH(p, uSeed), uSeaLevel), 1.0);
                    }
                }`
        });
        const exScene = new THREE.Scene(); const exCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        exScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), exMat));
        renderer.setRenderTarget(rt); renderer.render(exScene, exCam);
        const pixels = new Uint8Array(W*H*4); renderer.readRenderTargetPixels(rt,0,0,W,H,pixels);
        const fc = document.createElement('canvas'); fc.width = W; fc.height = H;
        const fctx = fc.getContext('2d');
        const img = fctx.createImageData(W,H); img.data.set(pixels); fctx.putImageData(img,0,0);
        const rc = document.createElement('canvas'); rc.width = W; rc.height = H;
        const rctx = rc.getContext('2d'); rctx.translate(0, H); rctx.scale(1, -1); rctx.drawImage(fc, 0, 0);
        const a = document.createElement('a'); a.download = ["Terrain","Cloud","Normal","HeightMap"][mode]+".png"; a.href = rc.toDataURL(); a.click();
        renderer.setRenderTarget(null);
        document.getElementById('toast').style.display='block'; setTimeout(()=>document.getElementById('toast').style.display='none',2000);
    }

    document.getElementById('btn-geo').onclick = () => doExport(0);
    document.getElementById('btn-cld').onclick = () => doExport(1);
    document.getElementById('btn-nor').onclick = () => doExport(2);
    document.getElementById('btn-hgt').onclick = () => doExport(3);

    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();
</script>
</body>
</html>
