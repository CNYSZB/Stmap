<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Planet Surface Generator - For Your Modeling</title>
    <style>
        :root { --accent: #00e5ff; --glass: rgba(15, 15, 15, 0.85); }
        body { margin: 0; background: #000; color: #fff; font-family: -apple-system, sans-serif; overflow: hidden; height: 100dvh; }
        
        /* 悬浮可拖拽面板 */
        #ui-panel {
            position: absolute; top: 100px; left: 20px;
            width: 320px; background: var(--glass);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15); border-radius: 24px;
            z-index: 1000; box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            touch-action: none; padding-bottom: 20px;
        }
        .drag-handle {
            width: 100%; height: 40px; display: flex; align-items: center; justify-content: center;
            cursor: move; background: rgba(255,255,255,0.05); border-radius: 24px 24px 0 0;
        }
        .drag-handle::after { content: ''; width: 40px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        .panel-content { padding: 0 20px; }
        .control-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 15px; }
        label { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; display: block; }
        
        input[type="number"] { width: 100%; background: #000; border: 1px solid #333; color: var(--accent); padding: 10px; border-radius: 10px; font-weight: bold; font-family: monospace; box-sizing: border-box; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #333; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: var(--accent); border-radius: 50%; cursor: pointer; border: 2px solid #000; }

        /* 导出按钮组 */
        .export-group { position: absolute; right: 20px; top: 20%; display: flex; flex-direction: column; gap: 15px; }
        .fab { width: 64px; height: 64px; border-radius: 50%; border: none; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: bold; cursor: pointer; transition: 0.2s; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        #btn-geo { background: var(--accent); color: #000; }
        #btn-cld { background: #fff; color: #000; }
        #btn-nor { background: #8080ff; color: #fff; }

        #toast { position: fixed; top: 30px; left: 50%; transform: translateX(-50%); background: #fff; color: #000; padding: 12px 25px; border-radius: 40px; font-size: 13px; font-weight: bold; display: none; z-index: 2000; }
    </style>
</head>
<body>

<div id="toast">贴图已生成并下载</div>

<div class="export-group">
    <button id="btn-geo" class="fab">导出<br>地形</button>
    <button id="btn-cld" class="fab">导出<br>云层</button>
    <button id="btn-nor" class="fab">导出<br>法线</button>
</div>

<div id="ui-panel">
    <div class="drag-handle" id="dragHandle"></div>
    <div class="panel-content">
        <label>星球种子</label>
        <input type="number" id="seedIn" value="40662">
        <div class="control-row">
            <div class="item"><label>海平面</label><input type="range" id="seaIn" min="20" max="80" value="48"></div>
            <div class="item"><label>云层密度</label><input type="range" id="cloudIn" min="0" max="100" value="50"></div>
            <div class="item"><label>北极推进</label><input type="range" id="iceNIn" min="0" max="160" value="30"></div>
            <div class="item"><label>南极推进</label><input type="range" id="iceSIn" min="0" max="160" value="30"></div>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

    const noiseShader = `
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            vec4 j = p - 49.0 * floor(p * (1.0/49.0));
            vec4 x_ = floor(j * (1.0/7.0)); vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * (2.0/7.0) - 1.0; vec4 y = y_ * (2.0/7.0) - 1.0;
            vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m; return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        float fbm(vec3 p, int oct) {
            float v = 0.0; float amp = 0.5;
            for (int i=0; i<8; i++) { if(i >= oct) break; v += amp * snoise(p); p *= 2.15; amp *= 0.5; }
            return v;
        }
    `;

    const planetLogic = `
        float getH(vec3 p, float uSeed) {
            vec3 sOff = vec3(uSeed * 0.13, uSeed * 0.47, uSeed * 0.71);
            return fbm(p * 1.5 + sOff, 8) * 0.5 + 0.5;
        }
        vec3 getPlanetColor(vec3 p, float uSeed, float uSeaLevel, float uIceN, float uIceS) {
            vec3 sOff = vec3(uSeed * 0.13, uSeed * 0.47, uSeed * 0.71);
            float h = getH(p, uSeed);
            bool isWater = h < uSeaLevel;
            vec3 col;
            
            if(isWater) {
                col = mix(vec3(0.05, 0.1, 0.22), vec3(0.01, 0.03, 0.08), smoothstep(0.0, 0.7, (uSeaLevel-h)/uSeaLevel));
            } else {
                float m = fbm(p * 2.5 + sOff + 100.0, 5) * 0.5 + 0.5;
                vec3 bio = mix(vec3(0.75, 0.65, 0.45), vec3(0.35, 0.5, 0.25), smoothstep(0.42, 0.48, m));
                bio = mix(bio, vec3(0.08, 0.28, 0.12), smoothstep(0.72, 0.78, m));
                col = mix(bio, vec3(0.35), smoothstep(0.4, 0.85, (h-uSeaLevel)));
            }

            // 冰盖分区颜色逻辑
            float noise = snoise(p * 10.0 + sOff) * 0.15; 
            float detail = snoise(p * 50.0) * 0.03; 
            float lat = p.y; 

            float nMask = smoothstep(1.1 - (uIceN/100.0) + noise, 1.25 - (uIceN/100.0) + noise, lat + detail);
            float sMask = smoothstep(-1.1 + (uIceS/100.0) - noise, -1.25 + (uIceS/100.0) - noise, lat - detail);
            float ice = max(nMask, sMask);

            vec3 landIce = vec3(0.98, 0.98, 1.0); // 纯奶白
            vec3 seaIce = vec3(0.75, 0.88, 0.98); // 浅蓝色
            vec3 iceCol = mix(landIce, seaIce, isWater ? 1.0 : 0.0);

            return mix(col, iceCol, ice);
        }
    `;

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(38, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 15;
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const pMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uSeaLevel:{value:0.48}, uIceN:{value:30}, uIceS:{value:30} },
        vertexShader: `varying vec3 vPos, vN; void main() { vPos = position; vN = normalize(normalMatrix*normal); gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `${noiseShader} ${planetLogic}
            varying vec3 vPos, vN; uniform float uSeed, uSeaLevel, uIceN, uIceS;
            void main() {
                vec3 p = normalize(vPos);
                vec3 c = getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS);
                float d = max(dot(vN, normalize(vec3(1,0.8,1))), 0.0) * 0.8 + 0.2;
                gl_FragColor = vec4(c * d, 1.0);
            }`
    });

    const cMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uCloud:{value:0.5} },
        vertexShader: `varying vec3 vPos; void main() { vPos = position; gl_Position = projectionMatrix*modelViewMatrix*vec4(position*1.03, 1.0); }`,
        fragmentShader: `${noiseShader}
            varying vec3 vPos; uniform float uSeed, uCloud;
            void main() {
                float n = fbm(normalize(vPos)*1.3 + uSeed + 500.0, 5)*0.5+0.5;
                gl_FragColor = vec4(vec3(1.0), smoothstep(1.0-uCloud, 1.2-uCloud, n)*0.8);
            }`,
        transparent: true, depthWrite: false
    });

    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), pMat));
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), cMat));

    // UI 拖拽逻辑
    const uiPanel = document.getElementById('ui-panel');
    const dragHandle = document.getElementById('dragHandle');
    let isDragging = false, offset = [0,0];
    dragHandle.onpointerdown = e => { isDragging = true; offset = [e.clientX-uiPanel.offsetLeft, e.clientY-uiPanel.offsetTop]; uiPanel.setPointerCapture(e.pointerId); };
    dragHandle.onpointermove = e => { if(!isDragging) return; uiPanel.style.left = (e.clientX-offset[0])+'px'; uiPanel.style.top = (e.clientY-offset[1])+'px'; };
    dragHandle.onpointerup = () => isDragging = false;

    const ui = { seed:document.getElementById('seedIn'), sea:document.getElementById('seaIn'), cloud:document.getElementById('cloudIn'), iceN:document.getElementById('iceNIn'), iceS:document.getElementById('iceSIn') };
    const sync = () => {
        pMat.uniforms.uSeed.value = cMat.uniforms.uSeed.value = parseFloat(ui.seed.value);
        pMat.uniforms.uSeaLevel.value = ui.sea.value/100;
        cMat.uniforms.uCloud.value = ui.cloud.value/100;
        pMat.uniforms.uIceN.value = ui.iceN.value; pMat.uniforms.uIceS.value = ui.iceS.value;
    };
    Object.values(ui).forEach(el => el.oninput = sync);

    function doExport(mode) {
        const W = 4096, H = 2048;
        const rt = new THREE.WebGLRenderTarget(W, H);
        const exMat = new THREE.ShaderMaterial({
            uniforms: { ...pMat.uniforms, uCloud:{value:cMat.uniforms.uCloud.value}, uMode:{value:mode} },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: `${noiseShader} ${planetLogic}
                varying vec2 vUv; uniform float uSeed, uSeaLevel, uIceN, uIceS, uCloud, uMode;
                void main() {
                    float lon = (vUv.x*2.0-1.0)*3.14159; float lat = (vUv.y*2.0-1.0)*1.5707;
                    vec3 p = vec3(cos(lat)*sin(lon), sin(lat), cos(lat)*cos(lon));
                    if(uMode == 0.0) gl_FragColor = vec4(getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS), 1.0);
                    else if(uMode == 1.0) gl_FragColor = vec4(vec3(1.0), smoothstep(1.0-uCloud, 1.2-uCloud, fbm(p*1.3+uSeed+500.0, 6)*0.5+0.5));
                    else {
                        float h = getH(p, uSeed);
                        if(h < uSeaLevel) { gl_FragColor = vec4(0.5, 0.5, 1.0, 1.0); return; } // 海洋一马平川
                        float eps = 0.0015;
                        float hR = getH(vec3(cos(lat)*sin(lon+eps), sin(lat), cos(lat)*cos(lon+eps)), uSeed);
                        float hU = getH(vec3(cos(lat+eps)*sin(lon), sin(lat+eps), cos(lat+eps)*cos(lon)), uSeed);
                        vec3 n = normalize(vec3((h-hR)*20.0, (h-hU)*20.0, 1.0));
                        gl_FragColor = vec4(n*0.5+0.5, 1.0);
                    }
                }`
        });
        const exScene = new THREE.Scene(); const exCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        exScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), exMat));
        renderer.setRenderTarget(rt); renderer.render(exScene, exCam);
        const pixels = new Uint8Array(W*H*4); renderer.readRenderTargetPixels(rt,0,0,W,H,pixels);
        const c = document.createElement('canvas'); c.width = W; c.height = H;
        const ctx = c.getContext('2d'); const img = ctx.createImageData(W,H); img.data.set(pixels); ctx.putImageData(img,0,0);
        const fc = document.createElement('canvas'); fc.width = W; fc.height = H;
        const fctx = fc.getContext('2d'); fctx.translate(0, H); fctx.scale(1, -1); fctx.drawImage(c, 0, 0);
        const a = document.createElement('a'); a.download = ["Terrain","Cloud","Normal"][mode]+".png"; a.href = fc.toDataURL(); a.click();
        renderer.setRenderTarget(null);
        document.getElementById('toast').style.display='block'; setTimeout(()=>document.getElementById('toast').style.display='none',2000);
    }

    document.getElementById('btn-geo').onclick = () => doExport(0);
    document.getElementById('btn-cld').onclick = () => doExport(1);
    document.getElementById('btn-nor').onclick = () => doExport(2);
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();
</script>
</body>
</html>
