<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>å†™å®è¡Œæ˜Ÿ - 12ä½æ— å†²çªæ­£å¼ç‰ˆ</title>
    <style>
        :root { --accent: #00e5ff; --glass: rgba(15, 15, 15, 0.9); }
        body { margin: 0; background: #000; color: #fff; font-family: -apple-system, sans-serif; overflow: hidden; height: 100dvh; }
        
        #menu-container {
            position: absolute; top: 12%; left: 20px;
            z-index: 1000; display: flex; flex-direction: column; gap: 10px;
        }
        #menu-toggle {
            background: var(--accent); color: #000; border: none; padding: 12px 20px;
            border-radius: 12px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0,229,255,0.3);
            width: fit-content;
        }
        #ui-panel {
            width: 300px; background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15); border-radius: 20px;
            padding: 20px; display: none; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }
        
        .seed-ctrl { display: flex; gap: 8px; align-items: center; margin-bottom: 15px; }
        #btn-rand { background: #444; color: #fff; border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 12px; white-space: nowrap; }
        #btn-rand:active { background: var(--accent); color: #000; }

        .control-row { display: grid; grid-template-columns: 1fr; gap: 15px; }
        label { font-size: 10px; color: #888; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; display: block; }
        input[type="number"] { flex-grow: 1; background: #000; border: 1px solid #333; color: var(--accent); padding: 8px; border-radius: 8px; box-sizing: border-box; font-family: monospace; font-size: 14px; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #333; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: var(--accent); border-radius: 50%; border: 2px solid #000; }

        .export-group { position: absolute; right: 20px; top: 20%; display: flex; flex-direction: column; gap: 12px; }
        .fab { width: 60px; height: 60px; border-radius: 50%; border: none; font-size: 10px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        #btn-geo { background: var(--accent); color: #000; }
        #btn-hgt { background: #ffaa00; color: #000; }
        #btn-cld { background: #fff; color: #000; }
        #btn-nor { background: #8080ff; color: #fff; }
        #btn-land { background: #33ff33; color: #000; }
        
        #toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: #fff; color: #000; padding: 10px 20px; border-radius: 30px; font-size: 12px; display: none; z-index: 2000; }
    </style>
</head>
<body>

<div id="toast">è´´å›¾å·²å¯¼å‡º</div>

<div id="menu-container">
    <button id="menu-toggle">â˜° æ˜Ÿçƒè®¾ç½®</button>
    <div id="ui-panel">
        <label>æ˜Ÿçƒç§å­ (1-12ä½ç‹¬ä¸€æ— äºŒ)</label>
        <div class="seed-ctrl">
            <input type="number" id="seedIn" value="40662" min="0" max="999999999999" oninput="if(value.length>12)value=value.slice(0,12)">
            <button id="btn-rand">ğŸ² éšæœº</button>
        </div>
        <div class="control-row">
            <div class="item"><label>æµ·å¹³é¢</label><input type="range" id="seaIn" min="20" max="80" value="48"></div>
            <div class="item"><label>äº‘å±‚å¯†åº¦</label><input type="range" id="cloudIn" min="0" max="100" value="50"></div>
            <div class="item"><label>èµ¤é“æ²™æ¼ åŒ–</label><input type="range" id="eqDesertIn" min="0" max="100" value="30"></div>
            <div class="item"><label>åŒ—ææ¨è¿›</label><input type="range" id="iceNIn" min="0" max="160" value="30"></div>
            <div class="item"><label>å—ææ¨è¿›</label><input type="range" id="iceSIn" min="0" max="160" value="30"></div>
        </div>
    </div>
</div>

<div class="export-group">
    <button id="btn-geo" class="fab">å¯¼å‡º<br>åœ°å½¢</button>
    <button id="btn-hgt" class="fab">å½©è‰²<br>é«˜åº¦å›¾</button>
    <button id="btn-cld" class="fab">å¯¼å‡º<br>äº‘å±‚</button>
    <button id="btn-nor" class="fab">å¯¼å‡º<br>æ³•çº¿</button>
    <button id="btn-land" class="fab">å¯¼å‡º<br>é™†åœ°</button>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

    const noiseShader = `
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            vec4 j = p - 49.0 * floor(p * (1.0/49.0));
            vec4 x_ = floor(j * (1.0/7.0)); vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * (2.0/7.0) - 1.0; vec4 y = y_ * (2.0/7.0) - 1.0;
            vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m; return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        
        float fbm(vec3 p, int oct, float shift) {
            float v = 0.0; float amp = 0.5;
            // ä½¿ç”¨ç§å­äº§ç”Ÿçš„é¢å¤–ä½ç§»é˜²æ­¢ FBM å åŠ å†²çª
            for (int i=0; i<8; i++) { 
                if(i >= oct) break; 
                v += amp * snoise(p + shift); 
                p *= 2.15; amp *= 0.5; 
            }
            return v;
        }

        // å¢å¼ºå‹å“ˆå¸Œç®—æ³•ï¼šé’ˆå¯¹ 12 ä½æ•´æ•°ä¼˜åŒ–
        // å°†ç§å­æ‹†è§£ä¸ºä¸‰ç»´æåæ ‡åç§»ï¼Œç¡®ä¿æ¯ä¸€ä½æ•°å­—çš„å˜åŒ–éƒ½ä¼šå¼•èµ·æ˜¾è‘—çš„ç©ºé—´æ‹“æ‰‘æ”¹å˜
        vec4 superHash(float seed) {
            float s1 = floor(seed / 1000000.0); // é«˜ 6 ä½
            float s2 = mod(seed, 1000000.0);    // ä½ 6 ä½
            
            vec3 p3 = fract(vec3(s1, s2, seed) * vec3(.1031, .1030, .0973));
            p3 += dot(p3, p3.yzx + 33.33);
            vec3 offset = fract((p3.xxy + p3.yzz) * p3.zyx) * 2000.0;
            
            // ç¬¬å››ä¸ªåˆ†é‡ç”¨äºæ§åˆ¶ç›¸ä½æ—‹è½¬
            float phase = fract(seed * 0.01313) * 6.28;
            return vec4(offset, phase);
        }
    `;

    const planetLogic = `
        float getH(vec3 p, float uSeed) {
            vec4 sh = superHash(uSeed);
            vec3 sOff = sh.xyz;
            // å¼•å…¥ç›¸ä½æ—‹è½¬ï¼Œå³ä½¿ sOff æ¥è¿‘ï¼Œæ—‹è½¬åçš„å™ªå£°ç»“æœä¹Ÿå®Œå…¨ä¸åŒ
            float c = cos(sh.w), s = sin(sh.w);
            p.xz *= mat2(c, -s, s, c);
            return fbm(p * 1.5 + sOff, 8, sh.w) * 0.5 + 0.5;
        }
        
        vec3 getHeightMapColor(float h, float uSeaLevel) {
            if(h < uSeaLevel) {
                return mix(vec3(0.0, 0.0, 0.3), vec3(0.0, 0.5, 1.0), h/uSeaLevel);
            } else {
                float landH = (h - uSeaLevel) / (1.0 - uSeaLevel);
                if(landH < 0.1) return mix(vec3(0.1, 0.6, 0.2), vec3(0.5, 0.8, 0.3), landH/0.1);
                if(landH < 0.4) return mix(vec3(0.5, 0.8, 0.3), vec3(0.9, 0.8, 0.5), (landH-0.1)/0.3);
                if(landH < 0.8) return mix(vec3(0.9, 0.8, 0.5), vec3(0.4, 0.2, 0.1), (landH-0.4)/0.4);
                return mix(vec3(0.4, 0.2, 0.1), vec3(1.0, 1.0, 1.0), (landH-0.8)/0.2);
            }
        }

        vec3 getPlanetColor(vec3 p, float uSeed, float uSeaLevel, float uIceN, float uIceS, float uEqDesert) {
            vec4 sh = superHash(uSeed);
            float h = getH(p, uSeed);
            bool isWater = h < uSeaLevel;
            float lat = p.y;
            
            vec3 col;
            if(isWater) {
                col = mix(vec3(0.05, 0.1, 0.22), vec3(0.01, 0.03, 0.08), smoothstep(0.0, 0.7, (uSeaLevel-h)/uSeaLevel));
            } else {
                // ç»†èŠ‚å™ªå£°ä¹Ÿå—ç›¸ä½æ§åˆ¶
                float m = fbm(p * 2.5 + sh.xyz + 123.4, 5, sh.w * 0.5) * 0.5 + 0.5;
                float desertStrength = uEqDesert / 100.0;
                float areaLimit = pow(max(0.0, 1.0 - abs(lat) * 1.5), 1.8); 
                float eqFactor = desertStrength * areaLimit;
                float finalBiomeFactor = mix(m, m * 0.15, eqFactor);
                vec3 bio = mix(vec3(0.75,0.65,0.45), vec3(0.35,0.5,0.25), smoothstep(0.35,0.45,finalBiomeFactor));
                bio = mix(bio, vec3(0.08,0.28,0.12), smoothstep(0.65,0.75,finalBiomeFactor));
                col = mix(bio, vec3(0.35), smoothstep(0.45, 0.85, (h-uSeaLevel)));
            }
            float noise = snoise(p * 10.0 + sh.xyz) * 0.15; 
            float detail = snoise(p * 50.0 + sh.xyz * 0.5) * 0.03; 
            float ice = max(smoothstep(1.1-(uIceN/100.0)+noise, 1.25-(uIceN/100.0)+noise, lat+detail),
                            smoothstep(-1.1+(uIceS/100.0)-noise, -1.25+(uIceS/100.0)-noise, lat-detail));
            return mix(col, mix(vec3(0.98,0.98,1.0), vec3(0.75,0.88,0.98), isWater?1.0:0.0), ice);
        }
    `;

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(38, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 15;
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const pMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uSeaLevel:{value:0.48}, uIceN:{value:30}, uIceS:{value:30}, uEqDesert:{value:30} },
        vertexShader: `varying vec3 vPos, vN; void main() { vPos = position; vN = normalize(normalMatrix*normal); gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `${noiseShader} ${planetLogic}
            varying vec3 vPos, vN; uniform float uSeed, uSeaLevel, uIceN, uIceS, uEqDesert;
            void main() {
                vec3 p = normalize(vPos);
                vec3 c = getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS, uEqDesert);
                float d = max(dot(vN, normalize(vec3(1,0.8,1))), 0.0) * 0.8 + 0.2;
                gl_FragColor = vec4(c * d, 1.0);
            }`
    });

    const cMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uCloud:{value:0.5} },
        vertexShader: `varying vec3 vPos; void main() { vPos = position; gl_Position = projectionMatrix*modelViewMatrix*vec4(position*1.03, 1.0); }`,
        fragmentShader: `${noiseShader}
            varying vec3 vPos; uniform float uSeed, uCloud;
            void main() {
                vec4 sh = superHash(uSeed);
                float n = fbm(normalize(vPos)*1.3 + sh.xyz + vec3(500.0), 5, sh.w)*0.5+0.5;
                gl_FragColor = vec4(vec3(1.0), smoothstep(1.0-uCloud, 1.2-uCloud, n)*0.8);
            }`,
        transparent: true, depthWrite: false
    });

    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), pMat));
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), cMat));

    const ui = { 
        seed: document.getElementById('seedIn'), 
        sea: document.getElementById('seaIn'), 
        cloud: document.getElementById('cloudIn'), 
        eqD: document.getElementById('eqDesertIn'), 
        iceN: document.getElementById('iceNIn'), 
        iceS: document.getElementById('iceSIn') 
    };

    const sync = () => {
        let sVal = parseFloat(ui.seed.value) || 0;
        pMat.uniforms.uSeed.value = cMat.uniforms.uSeed.value = sVal;
        pMat.uniforms.uSeaLevel.value = ui.sea.value/100;
        cMat.uniforms.uCloud.value = ui.cloud.value/100;
        pMat.uniforms.uEqDesert.value = parseFloat(ui.eqD.value);
        pMat.uniforms.uIceN.value = ui.iceN.value; 
        pMat.uniforms.uIceS.value = ui.iceS.value;
    };

    Object.values(ui).forEach(el => el.oninput = sync);

    document.getElementById('btn-rand').onclick = () => {
        // ç”Ÿæˆ 1 åˆ° 12 ä½çš„çœŸéšæœºæ•´æ•°
        const randomSeed = Math.floor(Math.random() * 999999999999) + 1;
        ui.seed.value = randomSeed;
        sync();
    };

    document.getElementById('menu-toggle').onclick = () => {
        const p = document.getElementById('ui-panel');
        p.style.display = p.style.display === 'block' ? 'none' : 'block';
    };

    function doExport(mode) {
        const W = 4096, H = 2048;
        const rt = new THREE.WebGLRenderTarget(W, H, { format: THREE.RGBAFormat });
        const exMat = new THREE.ShaderMaterial({
            uniforms: { ...pMat.uniforms, uCloud:{value:cMat.uniforms.uCloud.value}, uMode:{value:mode} },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
            fragmentShader: `${noiseShader} ${planetLogic}
                varying vec2 vUv; uniform float uSeed, uSeaLevel, uIceN, uIceS, uEqDesert, uCloud, uMode;
                void main() {
                    float lon = (vUv.x*2.0-1.0)*3.14159265; float lat = (vUv.y*2.0-1.0)*1.57079632;
                    vec3 p = vec3(cos(lat)*sin(lon), sin(lat), cos(lat)*cos(lon));
                    float h = getH(p, uSeed);
                    if(uMode == 0.0) gl_FragColor = vec4(getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS, uEqDesert), 1.0);
                    else if(uMode == 1.0) {
                        vec4 sh = superHash(uSeed);
                        float n = fbm(p*1.3+sh.xyz+vec3(500.0), 6, sh.w)*0.5+0.5;
                        gl_FragColor = vec4(vec3(1.0), smoothstep(1.0-uCloud, 1.2-uCloud, n));
                    }
                    else if(uMode == 2.0) {
                        float eps = 0.001;
                        float hR = getH(vec3(cos(lat)*sin(lon+eps), sin(lat), cos(lat)*cos(lon+eps)), uSeed);
                        float hU = getH(vec3(cos(lat+eps)*sin(lon), sin(lat+eps), cos(lat+eps)*cos(lon)), uSeed);
                        gl_FragColor = vec4(normalize(vec3((h-hR)*25.0, (h-hU)*25.0, 1.0))*0.5+0.5, 1.0);
                    } else if(uMode == 3.0) { 
                        gl_FragColor = vec4(getHeightMapColor(h, uSeaLevel), 1.0);
                    } else if(uMode == 4.0) {
                        if(h >= uSeaLevel) gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        else gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                    }
                }`,
            transparent: true
        });
        const exScene = new THREE.Scene(); const exCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        exScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), exMat));
        renderer.setRenderTarget(rt); renderer.render(exScene, exCam);
        const pixels = new Uint8Array(W*H*4); renderer.readRenderTargetPixels(rt,0,0,W,H,pixels);
        const fc = document.createElement('canvas'); fc.width = W; fc.height = H;
        const fctx = fc.getContext('2d');
        const img = fctx.createImageData(W,H); img.data.set(pixels); fctx.putImageData(img,0,0);
        const rc = document.createElement('canvas'); rc.width = W; rc.height = H;
        const rctx = rc.getContext('2d'); rctx.translate(0, H); rctx.scale(1, -1); rctx.drawImage(fc, 0, 0);
        const a = document.createElement('a'); a.download = ["Terrain","Cloud","Normal","HeightMap","LandMap"][mode]+".png"; a.href = rc.toDataURL(); a.click();
        renderer.setRenderTarget(null);
        document.getElementById('toast').style.display='block'; setTimeout(()=>document.getElementById('toast').style.display='none',2000);
    }

    document.getElementById('btn-geo').onclick = () => doExport(0);
    document.getElementById('btn-cld').onclick = () => doExport(1);
    document.getElementById('btn-nor').onclick = () => doExport(2);
    document.getElementById('btn-hgt').onclick = () => doExport(3);
    document.getElementById('btn-land').onclick = () => doExport(4);

    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();

    window.onresize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };
</script>
</body>
</html>
