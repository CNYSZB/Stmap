<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>写实行星 - 逻辑整合版</title>
    <style>
        :root { --accent: #00e5ff; --glass: rgba(15, 15, 15, 0.85); }
        body { margin: 0; background: #000; color: #fff; font-family: -apple-system, sans-serif; overflow: hidden; height: 100dvh; }
        #ui-panel { position: absolute; top: 100px; left: 20px; width: 320px; background: var(--glass); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.15); border-radius: 24px; z-index: 1000; padding-bottom: 20px; }
        .drag-handle { width: 100%; height: 40px; cursor: move; background: rgba(255,255,255,0.05); border-radius: 24px 24px 0 0; }
        .panel-content { padding: 0 20px; }
        .control-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 15px; }
        label { font-size: 10px; color: #888; text-transform: uppercase; margin-bottom: 4px; display: block; }
        input[type="number"] { width: 100%; background: #000; border: 1px solid #333; color: var(--accent); padding: 10px; border-radius: 10px; box-sizing: border-box; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #333; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: var(--accent); border-radius: 50%; border: 2px solid #000; }
        .export-group { position: absolute; right: 20px; top: 20%; display: flex; flex-direction: column; gap: 15px; }
        .fab { width: 64px; height: 64px; border-radius: 50%; border: none; font-size: 11px; font-weight: bold; cursor: pointer; }
        #btn-geo { background: var(--accent); color: #000; }
        #btn-cld { background: #fff; color: #000; }
        #btn-nor { background: #8080ff; color: #fff; }
    </style>
</head>
<body>

<div class="export-group">
    <button id="btn-geo" class="fab">导出<br>地形</button>
    <button id="btn-cld" class="fab">导出<br>云层</button>
    <button id="btn-nor" class="fab">导出<br>法线</button>
</div>

<div id="ui-panel">
    <div class="drag-handle"></div>
    <div class="panel-content">
        <label>星球种子</label>
        <input type="number" id="seedIn" value="40662">
        <div class="control-row">
            <div class="item"><label>海平面</label><input type="range" id="seaIn" min="20" max="80" value="48"></div>
            <div class="item"><label>云层密度</label><input type="range" id="cloudIn" min="0" max="100" value="50"></div>
            <div class="item"><label>赤道沙漠化</label><input type="range" id="eqDesertIn" min="0" max="100" value="30"></div>
            <div class="item"><label>北极推进</label><input type="range" id="iceNIn" min="0" max="160" value="30"></div>
            <div class="item"><label>南极推进</label><input type="range" id="iceSIn" min="0" max="160" value="30"></div>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

    const noiseShader = `
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            vec4 j = p - 49.0 * floor(p * (1.0/49.0));
            vec4 x_ = floor(j * (1.0/7.0)); vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * (2.0/7.0) - 1.0; vec4 y = y_ * (2.0/7.0) - 1.0;
            vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m; return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        float fbm(vec3 p, int oct) {
            float v = 0.0; float amp = 0.5;
            for (int i=0; i<8; i++) { if(i >= oct) break; v += amp * snoise(p); p *= 2.15; amp *= 0.5; }
            return v;
        }
    `;

    const planetLogic = `
        float getH(vec3 p, float uSeed) {
            vec3 sOff = vec3(uSeed * 0.13, uSeed * 0.47, uSeed * 0.71);
            return fbm(p * 1.5 + sOff, 8) * 0.5 + 0.5;
        }
        vec3 getPlanetColor(vec3 p, float uSeed, float uSeaLevel, float uIceN, float uIceS, float uEqDesert) {
            vec3 sOff = vec3(uSeed * 0.13, uSeed * 0.47, uSeed * 0.71);
            float h = getH(p, uSeed);
            bool isWater = h < uSeaLevel;
            float lat = p.y; // 极地逻辑需要带符号的y
            
            // --- 陆地/海洋基础色逻辑 ---
            vec3 col;
            if(isWater) {
                col = mix(vec3(0.05, 0.1, 0.22), vec3(0.01, 0.03, 0.08), smoothstep(0.0, 0.7, (uSeaLevel-h)/uSeaLevel));
            } else {
                // 赤道沙漠预处理 (搬运之前的优化逻辑)
                float m = fbm(p * 2.5 + sOff + 100.0, 5) * 0.5 + 0.5;
                float desertStrength = uEqDesert / 100.0;
                float areaLimit = pow(max(0.0, 1.0 - abs(lat) * 1.5), 1.8); 
                float eqFactor = desertStrength * areaLimit;
                float finalBiomeFactor = mix(m, m * 0.15, eqFactor);

                vec3 desertCol = vec3(0.75, 0.65, 0.45);
                vec3 grassCol  = vec3(0.35, 0.5, 0.25);
                vec3 forestCol = vec3(0.08, 0.28, 0.12);
                vec3 bio = mix(desertCol, grassCol, smoothstep(0.35, 0.45, finalBiomeFactor));
                bio = mix(bio, forestCol, smoothstep(0.65, 0.75, finalBiomeFactor));
                col = mix(bio, vec3(0.35), smoothstep(0.45, 0.85, (h-uSeaLevel)));
            }

            // --- 搬运：南北极冰盖逻辑 ---
            float noise = snoise(p * 10.0 + sOff) * 0.15; 
            float detail = snoise(p * 50.0) * 0.03; 

            float nMask = smoothstep(1.1 - (uIceN/100.0) + noise, 1.25 - (uIceN/100.0) + noise, lat + detail);
            float sMask = smoothstep(-1.1 + (uIceS/100.0) - noise, -1.25 + (uIceS/100.0) - noise, lat - detail);
            float ice = max(nMask, sMask);

            vec3 landIce = vec3(0.98, 0.98, 1.0); // 纯奶白
            vec3 seaIce = vec3(0.75, 0.88, 0.98); // 浅蓝色
            vec3 iceCol = mix(landIce, seaIce, isWater ? 1.0 : 0.0);

            return mix(col, iceCol, ice);
        }
    `;

    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(38, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 15;
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const pMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uSeaLevel:{value:0.48}, uIceN:{value:30}, uIceS:{value:30}, uEqDesert:{value:30} },
        vertexShader: `varying vec3 vPos, vN; void main() { vPos = position; vN = normalize(normalMatrix*normal); gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `${noiseShader} ${planetLogic}
            varying vec3 vPos, vN; uniform float uSeed, uSeaLevel, uIceN, uIceS, uEqDesert;
            void main() {
                vec3 p = normalize(vPos);
                vec3 c = getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS, uEqDesert);
                float d = max(dot(vN, normalize(vec3(1,0.8,1))), 0.0) * 0.8 + 0.2;
                gl_FragColor = vec4(c * d, 1.0);
            }`
    });

    const cMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:40662}, uCloud:{value:0.5} },
        vertexShader: `varying vec3 vPos; void main() { vPos = position; gl_Position = projectionMatrix*modelViewMatrix*vec4(position*1.03, 1.0); }`,
        fragmentShader: `${noiseShader}
            varying vec3 vPos; uniform float uSeed, uCloud;
            void main() {
                float n = fbm(normalize(vPos)*1.3 + uSeed + 500.0, 5)*0.5+0.5;
                gl_FragColor = vec4(vec3(1.0), smoothstep(1.0-uCloud, 1.2-uCloud, n)*0.8);
            }`,
        transparent: true, depthWrite: false
    });

    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), pMat));
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), cMat));

    const ui = { seed:document.getElementById('seedIn'), sea:document.getElementById('seaIn'), cloud:document.getElementById('cloudIn'), eqD:document.getElementById('eqDesertIn'), iceN:document.getElementById('iceNIn'), iceS:document.getElementById('iceSIn') };
    const sync = () => {
        pMat.uniforms.uSeed.value = cMat.uniforms.uSeed.value = parseFloat(ui.seed.value);
        pMat.uniforms.uSeaLevel.value = ui.sea.value/100;
        cMat.uniforms.uCloud.value = ui.cloud.value/100;
        pMat.uniforms.uEqDesert.value = parseFloat(ui.eqD.value);
        pMat.uniforms.uIceN.value = ui.iceN.value; pMat.uniforms.uIceS.value = ui.iceS.value;
    };
    Object.values(ui).forEach(el => el.oninput = sync);

    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();
</script>
</body>
</html>
