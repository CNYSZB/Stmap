<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>写实行星 - 全悬浮交互版</title>
    <style>
        :root { --accent: #00e5ff; }
        body { 
            margin: 0; background: #000; color: #fff; 
            font-family: -apple-system, system-ui, sans-serif; 
            overflow: hidden; height: 100dvh;
        }
        
        #app { width: 100vw; height: 100dvh; position: relative; }
        canvas { width: 100%; height: 100%; display: block; }

        /* 改造后的悬浮控制面板 */
        #ui-panel {
            position: absolute; 
            bottom: 40px; left: 20px; /* 初始位置稍高，避开默认底栏 */
            width: 280px;
            background: rgba(25, 25, 25, 0.7);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 15px;
            box-sizing: border-box; z-index: 90;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            touch-action: none; /* 必须，用于自定义拖拽 */
            user-select: none;
        }

        /* 顶部拖拽手柄指示器 */
        .drag-handle {
            width: 40px; height: 4px; background: rgba(255,255,255,0.2);
            margin: -5px auto 10px; border-radius: 2px;
        }

        .seed-row { display: flex; gap: 8px; margin-bottom: 12px; align-items: flex-end; }
        .seed-row .item { flex: 1; }
        .btn-rand { 
            height: 36px; padding: 0 12px; background: #444; color: #fff;
            border: none; border-radius: 8px; font-size: 12px; font-weight: bold;
        }

        .control-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .item { display: flex; flex-direction: column; }
        label { font-size: 9px; color: #aaa; margin-bottom: 4px; text-transform: uppercase; pointer-events: none; }

        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: #333; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px; background: var(--accent); border-radius: 50%;
        }

        input[type="number"] {
            width: 100%; background: #111; border: 1px solid #333; color: var(--accent); 
            padding: 8px; border-radius: 6px; font-size: 13px; box-sizing: border-box;
        }

        /* 悬浮导出按钮 */
        #export-fab {
            position: absolute;
            right: 20px; top: 40px; /* 初始在右上角 */
            width: 56px; height: 56px;
            background: var(--accent); color: #000;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 11px; font-weight: 900; line-height: 1.2; text-align: center;
            box-shadow: 0 4px 15px rgba(0, 229, 255, 0.4);
            cursor: move; touch-action: none; z-index: 1000;
        }

        #toast {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: var(--accent); color: #000; padding: 8px 16px;
            border-radius: 20px; font-size: 11px; font-weight: bold;
            display: none; z-index: 1100;
        }
    </style>
</head>
<body>

<div id="toast">高清 2K 渲染中...</div>

<div id="app">
    <div id="export-fab">导出<br>2K</div>

    <div id="ui-panel">
        <div class="drag-handle"></div>
        <div class="seed-row">
            <div class="item">
                <label>星球种子 SEED</label>
                <input type="number" id="seedIn" value="123456">
            </div>
            <button class="btn-rand" id="randBtn">随机</button>
        </div>
        
        <div class="control-group">
            <div class="item"><label>海平面</label><input type="range" id="seaIn" min="20" max="80" value="48"></div>
            <div class="item"><label>云量</label><input type="range" id="cloudIn" min="0" max="100" value="45"></div>
            <div class="item"><label>北极</label><input type="range" id="iceNIn" min="0" max="100" value="28"></div>
            <div class="item"><label>南极</label><input type="range" id="iceSIn" min="0" max="100" value="32"></div>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

    // --- 通用拖拽函数 ---
    function setupDraggable(el) {
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;

        el.addEventListener('touchstart', (e) => {
            // 如果点到的是输入框或滑块，不触发面板拖拽
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
            isDragging = true;
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
            initialLeft = el.offsetLeft;
            initialTop = el.offsetTop;
            el.style.transition = 'none';
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const touch = e.touches[0];
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;
            el.style.left = (initialLeft + dx) + 'px';
            el.style.top = (initialTop + dy) + 'px';
            el.style.bottom = 'auto'; // 覆盖初始的 bottom 定位
        }, { passive: false });

        document.addEventListener('touchend', () => { isDragging = false; });
    }

    setupDraggable(document.getElementById('ui-panel'));
    setupDraggable(document.getElementById('export-fab'));

    // --- 渲染逻辑 (此处完整沿用您提供的核心算法) ---
    const noiseLib = `
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            vec4 j = p - 49.0 * floor(p * (1.0/49.0));
            vec4 x_ = floor(j * (1.0/7.0)); vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ * (2.0/7.0) - 1.0; vec4 y = y_ * (2.0/7.0) - 1.0;
            vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x); vec3 p1 = vec3(a0.zw, h.y); vec3 p2 = vec3(a1.xy, h.z); vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m; return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        float fbm(vec3 p, int oct) {
            float v = 0.0; float amp = 0.5;
            for (int i=0; i<8; i++) { if(i >= oct) break; v += amp * snoise(p); p *= 2.15; amp *= 0.5; }
            return v;
        }
    `;

    const corePlanetLogic = `
        vec3 getPlanetColor(vec3 p, float uSeed, float uSeaLevel, float uIceN, float uIceS) {
            vec3 sOff = vec3(uSeed * 0.17, uSeed * 0.43, uSeed * 0.81);
            float h = fbm(p * 1.6 + sOff, 8) * 0.5 + 0.5;
            float moisture = fbm(p * 2.3 + sOff + 200.0, 5) * 0.5 + 0.5;
            float detail = snoise(p * 55.0 + sOff) * 0.04; 
            vec3 col;
            bool isWater = h < uSeaLevel;
            if(isWater) {
                float d = (uSeaLevel - h) / uSeaLevel;
                col = mix(vec3(0.05, 0.12, 0.28), vec3(0.01, 0.03, 0.08), smoothstep(0.0, 0.7, d));
            } else {
                float relH = (h - uSeaLevel) / (1.0 - uSeaLevel);
                vec3 desert = vec3(0.8, 0.65, 0.45), plain = vec3(0.35, 0.5, 0.25), forest = vec3(0.08, 0.25, 0.1);
                vec3 bio = mix(desert, plain, smoothstep(0.42, 0.48, moisture + detail));
                bio = mix(bio, forest, smoothstep(0.72, 0.78, moisture + detail));
                col = mix(bio, vec3(0.35, 0.3, 0.28), smoothstep(0.4, 0.85, relH + detail));
            }
            float lat = p.y;
            float iceField = snoise(p * 8.0 + sOff * 0.5) * 0.08 + snoise(p * 35.0) * 0.03;
            float nLim = 1.15 - (uIceN/100.0) + iceField;
            float sLim = -1.15 + (uIceS/100.0) - iceField;
            float iceMask = 0.0;
            if(lat > nLim) iceMask = smoothstep(nLim, nLim + 0.06, lat);
            if(lat < sLim) iceMask = smoothstep(sLim, sLim - 0.06, lat);
            vec3 iceColor = isWater ? vec3(0.8, 0.95, 1.0) : vec3(0.98, 0.99, 1.0) * (0.9 + detail * 2.5);
            return mix(col, iceColor, iceMask);
        }
    `;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('app').appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const planetMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:123456}, uSeaLevel:{value:0.48}, uIceN:{value:28}, uIceS:{value:32}, uSunDir:{value:new THREE.Vector3(1,0.5,0.8).normalize()} },
        vertexShader: `varying vec3 vNormal, vPos; void main() { vNormal = normalize(normalMatrix*normal); vPos = position; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `${noiseLib} ${corePlanetLogic}
            varying vec3 vNormal, vPos; uniform float uSeed, uSeaLevel, uIceN, uIceS; uniform vec3 uSunDir;
            void main() {
                vec3 col = getPlanetColor(normalize(vPos), uSeed, uSeaLevel, uIceN, uIceS);
                gl_FragColor = vec4(col * (max(dot(vNormal, uSunDir), 0.0) + 0.1), 1.0);
            }`
    });
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), planetMat));

    const cloudMat = new THREE.ShaderMaterial({
        uniforms: { uSeed:{value:123456}, uTime:{value:0}, uCloud:{value:0.45}, uSunDir:{value:new THREE.Vector3(1,0.5,0.8).normalize()} },
        vertexShader: `varying vec3 vNormal, vPos; void main() { vNormal = normalize(normalMatrix*normal); vPos = position; gl_Position = projectionMatrix*modelViewMatrix*vec4(position * 1.02, 1.0); }`,
        fragmentShader: `${noiseLib}
            varying vec3 vNormal, vPos; uniform float uSeed, uTime, uCloud; uniform vec3 uSunDir;
            void main() {
                float n = fbm(normalize(vPos) * 1.2 + uTime * 0.005 + uSeed + 888.0, 5) * 0.5 + 0.5;
                float alpha = smoothstep(1.0 - uCloud, 1.2 - uCloud, n);
                gl_FragColor = vec4(vec3(1.0) * (max(dot(vNormal, uSunDir), 0.0) + 0.2), alpha * 0.7);
            }`,
        transparent: true, depthWrite: false
    });
    scene.add(new THREE.Mesh(new THREE.SphereGeometry(5, 128, 128), cloudMat));

    const uiElements = { seed:document.getElementById('seedIn'), sea:document.getElementById('seaIn'), cloud:document.getElementById('cloudIn'), iceN:document.getElementById('iceNIn'), iceS:document.getElementById('iceSIn') };
    const sync = () => {
        const s = parseFloat(uiElements.seed.value);
        planetMat.uniforms.uSeed.value = s; cloudMat.uniforms.uSeed.value = s + 555;
        planetMat.uniforms.uSeaLevel.value = uiElements.sea.value / 100; cloudMat.uniforms.uCloud.value = uiElements.cloud.value / 100;
        planetMat.uniforms.uIceN.value = uiElements.iceN.value; planetMat.uniforms.uIceS.value = uiElements.iceS.value;
    };
    Object.values(uiElements).forEach(el => el.oninput = sync);
    document.getElementById('randBtn').onclick = () => { uiElements.seed.value = Math.floor(Math.random()*999999); sync(); };

    document.getElementById('export-fab').addEventListener('click', (e) => {
        // 只有不是在拖拽时才触发
        document.getElementById('toast').style.display = 'block';
        setTimeout(() => {
            const W = 2048, H = 1024;
            const rt = new THREE.WebGLRenderTarget(W, H);
            const exMat = new THREE.ShaderMaterial({
                uniforms: { ...planetMat.uniforms, ...cloudMat.uniforms },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
                fragmentShader: `${noiseLib} ${corePlanetLogic}
                    uniform float uSeed, uSeaLevel, uIceN, uIceS, uCloud, uTime; varying vec2 vUv;
                    void main() {
                        float lon = (vUv.x * 2.0 - 1.0) * 3.14159265;
                        float lat = (vUv.y * 2.0 - 1.0) * (3.14159265 / 2.0);
                        vec3 p = vec3(cos(lat)*sin(lon), sin(lat), cos(lat)*cos(lon));
                        vec3 terrain = getPlanetColor(p, uSeed, uSeaLevel, uIceN, uIceS);
                        float n = fbm(p * 1.2 + uTime * 0.005 + uSeed + 888.0, 5) * 0.5 + 0.5;
                        float cloudAlpha = smoothstep(1.0 - uCloud, 1.2 - uCloud, n);
                        gl_FragColor = vec4(mix(terrain, vec3(1.0), cloudAlpha * 0.7), 1.0);
                    }`
            });
            const exScene = new THREE.Scene();
            const exCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            exScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), exMat));
            renderer.setRenderTarget(rt);
            renderer.render(exScene, exCam);
            const pixels = new Uint8Array(W * H * 4);
            renderer.readRenderTargetPixels(rt, 0, 0, W, H, pixels);
            const canvas = document.createElement('canvas'); canvas.width = W; canvas.height = H;
            const ctx = canvas.getContext('2d'); const imgData = ctx.createImageData(W, H);
            imgData.data.set(pixels); ctx.putImageData(imgData, 0, 0);
            const a = document.createElement('a'); a.download = `Planet_${uiElements.seed.value}.png`;
            a.href = canvas.toDataURL(); a.click();
            renderer.setRenderTarget(null); document.getElementById('toast').style.display = 'none';
        }, 100);
    });

    function animate() {
        requestAnimationFrame(animate);
        cloudMat.uniforms.uTime.value += 0.01;
        controls.update();
        renderer.render(scene, camera);
    }
    window.onresize = () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    };
    animate();
</script>
</body>
</html>